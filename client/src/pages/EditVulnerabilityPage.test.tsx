import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import EditVulnerabilityPage from './EditVulnerabilityPage';
import { Vulnerability, VulnerabilityFormData } from '../../components/forms/VulnerabilityForm';
import { vulnerabilitySeverityEnum } from '@shared/schema';

// Mock wouter hooks
const mockSetLocation = jest.fn();
const mockVulnerabilityId = '1';

jest.mock('wouter', () => ({
  ...jest.requireActual('wouter'),
  useLocation: () => [null, mockSetLocation],
  useRoute: () => [true, { id: mockVulnerabilityId }], // Mock params for vulnerabilityId
  Link: ({ children, href }: { children: React.ReactNode, href: string }) => <a href={href}>{children}</a>,
}));

// Mock fetch
global.fetch = jest.fn();
const mockFetch = global.fetch as jest.Mock;

const mockInitialVulnerabilityData: Vulnerability = {
  id: parseInt(mockVulnerabilityId),
  name: 'Initial Vuln Name',
  description: 'Initial Description',
  severity: vulnerabilitySeverityEnum.enumValues[0], // critical
  cvssScore: '10.0',
  references: ['http://initial.com/ref'],
  source: 'Initial Source',
  createdAt: new Date().toISOString(),
  updatedAt: new Date().toISOString(),
};

describe('EditVulnerabilityPage Component', () => {
  beforeEach(() => {
    mockSetLocation.mockClear();
    mockFetch.mockClear();
  });

  test('fetches vulnerability data and populates form', async () => {
    mockFetch.mockResolvedValueOnce({
      ok: true,
      json: async () => mockInitialVulnerabilityData,
    } as Response);

    render(<EditVulnerabilityPage />);

    expect(mockFetch).toHaveBeenCalledTimes(1);
    expect(mockFetch).toHaveBeenCalledWith(`/api/vulnerabilities/${mockVulnerabilityId}`, expect.any(Object));

    // Wait for form to populate
    expect(await screen.findByLabelText(/Name/i)).toHaveValue(mockInitialVulnerabilityData.name);
    expect(screen.getByLabelText(/Description/i)).toHaveValue(mockInitialVulnerabilityData.description);
    expect(screen.getByLabelText(/Severity/i)).toHaveValue(mockInitialVulnerabilityData.severity);
    expect(screen.getByLabelText(/CVSS Score/i)).toHaveValue(mockInitialVulnerabilityData.cvssScore);
    expect(screen.getByLabelText(/Source/i)).toHaveValue(mockInitialVulnerabilityData.source);
    expect(screen.getByLabelText(/References/i)).toHaveValue((mockInitialVulnerabilityData.references as string[]).join('\n'));
    expect(screen.getByRole('button', { name: /Save Changes/i})).toBeInTheDocument();
  });

  test('handles successful form submission and redirect', async () => {
    const user = userEvent.setup();
    // First fetch for initial data
    mockFetch.mockResolvedValueOnce({
      ok: true,
      json: async () => mockInitialVulnerabilityData,
    } as Response);
    // Second fetch for PUT request
    mockFetch.mockResolvedValueOnce({
      ok: true,
      json: async () => ({ ...mockInitialVulnerabilityData, name: 'Updated Vuln Name' }),
    } as Response);

    render(<EditVulnerabilityPage />);
    
    // Wait for form to be populated
    const nameInput = await screen.findByLabelText(/Name/i);
    expect(nameInput).toHaveValue(mockInitialVulnerabilityData.name);

    // Update a field
    const updatedName = "Updated Vuln Name Via Edit Page";
    await user.clear(nameInput);
    await user.type(nameInput, updatedName);
    
    fireEvent.submit(screen.getByRole('button', { name: /Save Changes/i }));

    await waitFor(() => {
      // Called twice: GET then PUT
      expect(mockFetch).toHaveBeenCalledTimes(2); 
      expect(mockFetch).toHaveBeenLastCalledWith(`/api/vulnerabilities/${mockVulnerabilityId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          name: updatedName,
          description: mockInitialVulnerabilityData.description,
          severity: mockInitialVulnerabilityData.severity,
          cvssScore: mockInitialVulnerabilityData.cvssScore,
          references: mockInitialVulnerabilityData.references,
          source: mockInitialVulnerabilityData.source,
        }),
      });
    });

    await waitFor(() => {
      expect(mockSetLocation).toHaveBeenCalledWith('/'); // Or redirect target
    });
  });

  test('displays error if fetching initial data fails', async () => {
    const fetchErrorMsg = "Vulnerability not found.";
    mockFetch.mockResolvedValueOnce({
      ok: false,
      status: 404,
      json: async () => ({ message: fetchErrorMsg }),
    } as Response);

    render(<EditVulnerabilityPage />);

    expect(await screen.findByText(new RegExp(fetchErrorMsg, "i"))).toBeInTheDocument();
    expect(screen.queryByLabelText(/Name/i)).not.toBeInTheDocument(); // Form should not render or be usable
  });

  test('displays error message on API failure during update', async () => {
    const user = userEvent.setup();
    const updateErrorMsg = "Update failed";
    // First fetch for initial data - success
    mockFetch.mockResolvedValueOnce({
      ok: true,
      json: async () => mockInitialVulnerabilityData,
    } as Response);
    // Second fetch for PUT - failure
    mockFetch.mockResolvedValueOnce({
      ok: false,
      json: async () => ({ message: updateErrorMsg }),
    } as Response);

    render(<EditVulnerabilityPage />);
    const nameInput = await screen.findByLabelText(/Name/i); // Ensure form is loaded
    await user.type(nameInput, " - Attempt Update"); // Make a change

    fireEvent.submit(screen.getByRole('button', { name: /Save Changes/i }));
    
    expect(await screen.findByText(new RegExp(updateErrorMsg, "i"))).toBeInTheDocument();
    expect(mockSetLocation).not.toHaveBeenCalled();
  });
});
