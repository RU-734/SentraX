import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import AddVulnerabilityPage from './AddVulnerabilityPage';
import { VulnerabilityFormData } from '../../components/forms/VulnerabilityForm';

// Mock wouter hooks
const mockSetLocation = jest.fn();
jest.mock('wouter', () => ({
  ...jest.requireActual('wouter'), // Import and retain default behavior
  useLocation: () => [null, mockSetLocation], // Mock useLocation to check redirection
  Link: ({ children, href }: { children: React.ReactNode, href: string }) => <a href={href}>{children}</a>,
}));

// Mock fetch
global.fetch = jest.fn();

const mockFetch = global.fetch as jest.Mock;

describe('AddVulnerabilityPage Component', () => {
  beforeEach(() => {
    mockSetLocation.mockClear();
    mockFetch.mockClear();
  });

  test('renders VulnerabilityForm and handles successful submission', async () => {
    const user = userEvent.setup();
    mockFetch.mockResolvedValueOnce({
      ok: true,
      json: async () => ({ id: 123, message: 'Vulnerability created' }),
    } as Response);

    render(<AddVulnerabilityPage />);

    expect(screen.getByText(/Add New Vulnerability/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /Add Vulnerability/i })).toBeInTheDocument(); // Form's submit button

    // Fill out the form (simplified, assuming VulnerabilityForm tests cover field interactions)
    const testData: VulnerabilityFormData = {
      name: 'Test Add Vuln',
      description: 'Desc for Add',
      severity: 'high',
      cvssScore: '8.0',
      source: 'Test Source',
      references: ['http://test.com/add'],
    };
    
    await user.type(screen.getByLabelText(/Name/i), testData.name);
    await user.type(screen.getByLabelText(/Description/i), testData.description);
    await user.selectOptions(screen.getByLabelText(/Severity/i), testData.severity);
    await user.type(screen.getByLabelText(/CVSS Score/i), testData.cvssScore as string);
    await user.type(screen.getByLabelText(/Source/i), testData.source as string);
    await user.type(screen.getByLabelText(/References/i), (testData.references as string[]).join('\n'));

    fireEvent.submit(screen.getByRole('button', { name: /Add Vulnerability/i }));

    await waitFor(() => {
      expect(mockFetch).toHaveBeenCalledTimes(1);
      expect(mockFetch).toHaveBeenCalledWith('/api/vulnerabilities', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(testData),
      });
    });

    await waitFor(() => {
      expect(mockSetLocation).toHaveBeenCalledWith('/'); // Or whatever the redirect target is
    });
  });

  test('displays error message on API failure', async () => {
    const user = userEvent.setup();
    const errorMessage = 'Failed to create';
    mockFetch.mockResolvedValueOnce({
      ok: false,
      json: async () => ({ message: errorMessage }),
    } as Response);

    render(<AddVulnerabilityPage />);
    
    // Minimal form fill for submission
    await user.type(screen.getByLabelText(/Name/i), 'Fail Test');
    await user.type(screen.getByLabelText(/Description/i), 'Fail Desc');
    await user.selectOptions(screen.getByLabelText(/Severity/i), 'low');

    fireEvent.submit(screen.getByRole('button', { name: /Add Vulnerability/i }));

    await waitFor(() => {
      expect(mockFetch).toHaveBeenCalledTimes(1);
    });
    
    expect(await screen.findByText(new RegExp(errorMessage, "i"))).toBeInTheDocument();
    expect(mockSetLocation).not.toHaveBeenCalled();
  });
});
